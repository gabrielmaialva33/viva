/*
 * VIVA Music Bridge - Arduino Controller
 * AUTO-GENERATED BY VIVA EVOLUTION ENGINE
 *
 * Generation: <%= @g.generation %>
 * Fitness: <%= Float.round(@g.fitness, 4) %>
 * PWM Frequency: <%= Float.round(16_000_000 / (@g.timer.prescaler * (1 + @g.timer.top)) / 1000, 1) %> kHz
 *
 * DO NOT EDIT - This file is regenerated by VIVA's genetic algorithm
 * Source: VivaBridge.Firmware.Codegen
 */

// Pin definitions - evolved from genotype
#define SPEAKER_PIN <%= @g.pins.speaker %>
#define BUZZER_PIN <%= @g.pins.buzzer %>
#define FAN_PWM_PIN <%= @g.pins.fan_pwm %>
#define FAN_TACH_PIN <%= @g.pins.fan_tach %>
#define LED_PIN <%= @g.pins.led %>

// Timer configuration for PWM
#define TIMER_TOP <%= @g.timer.top %>

// Harmony ratio (buzzer frequency multiplier)
#define HARMONY_RATIO <%= @g.harmony_ratio %>

// RPM counting
volatile unsigned long pulseCount = 0;
unsigned long lastRpmCalc = 0;
unsigned int fanRPM = 0;

// Fan state
byte fanPWM = 128;
bool harmonyEnabled = true;

// Interrupt handler - counts TACH pulses
void countPulse() { pulseCount++; }

// Set fan speed using Timer1 (25kHz PWM)
void setFanSpeed(byte pwm) {
  fanPWM = pwm;
  // Map 0-255 to 0-TIMER_TOP
  OCR1B = map(pwm, 0, 255, 0, ICR1);
}

void setup() {
  Serial.begin(<%= @g.serial_baud %>);

  pinMode(SPEAKER_PIN, OUTPUT);
  pinMode(BUZZER_PIN, OUTPUT);
  pinMode(FAN_PWM_PIN, OUTPUT);
  pinMode(LED_PIN, OUTPUT);
  pinMode(FAN_TACH_PIN, INPUT_PULLUP);

  // Timer1: Fast PWM on pin D10 (OC1B)
  // f_PWM = 16MHz / (prescaler * (1 + TOP))
  TCCR1A = _BV(COM1B1) | _BV(WGM11);
  TCCR1B = _BV(WGM13) | _BV(WGM12) | _BV(CS1<%= case @g.timer.prescaler do
    1 -> "0"
    8 -> "1"
    64 -> "1) | _BV(CS10"
    256 -> "2"
    1024 -> "2) | _BV(CS10"
  end %>);
  ICR1 = TIMER_TOP;

  // Set initial speed (50%)
  setFanSpeed(fanPWM);

  // Attach interrupt on FALLING edge (tach pulses low)
  attachInterrupt(digitalPinToInterrupt(FAN_TACH_PIN), countPulse, FALLING);

  // Startup blink
  digitalWrite(LED_PIN, HIGH);
  delay(200);
  digitalWrite(LED_PIN, LOW);

  Serial.println("VIVA_READY");
  Serial.setTimeout(<%= @g.serial_timeout %>);
}

uint32_t calculateCRC32(String data) {
  uint32_t crc = 0xFFFFFFFF;
  for (int i = 0; i < data.length(); i++) {
    char c = data.charAt(i);
    crc ^= c;
    for (int j = 0; j < 8; j++) {
      if (crc & 1)
        crc = (crc >> 1) ^ 0xEDB88320;
      else
        crc >>= 1;
    }
  }
  return ~crc;
}

void loop() {
  // 1. RPM Calculation (every 1 second)
  unsigned long currentMillis = millis();
  unsigned long dt = currentMillis - lastRpmCalc;

  if (dt >= 1000) {
    noInterrupts();
    unsigned int pulses = pulseCount;
    pulseCount = 0;
    interrupts();

    // RPM = (Pulses / 2) * 60000 / dt_ms
    fanRPM = (unsigned int)(((unsigned long)pulses * 30000) / dt);

    lastRpmCalc = currentMillis;
  }

  // 2. Command Processing
  if (Serial.available() > 0) {
    String input = Serial.readStringUntil('\n');
    input.trim();

    if (input.length() > 0) {
      int separator = input.lastIndexOf('|');
      if (separator == -1) {
        Serial.println("NAK:NO_CRC");
        return;
      }

      String cmdPart = input.substring(0, separator);
      String crcPart = input.substring(separator + 1);

      uint32_t calced = calculateCRC32(cmdPart);
      uint32_t received = strtoul(crcPart.c_str(), NULL, 16);

      if (calced != received) {
        Serial.print("NAK:CRC_FAIL:");
        Serial.print(calced, HEX);
        Serial.print("!=");
        Serial.println(received, HEX);
        return;
      }

      processCommand(cmdPart);
    }
  }
}

void processCommand(String input) {
  char cmd = input.charAt(0);
  String arg = input.length() > 2 ? input.substring(2) : "";

  digitalWrite(LED_PIN, HIGH);

  switch (cmd) {
  case 'P': // Ping
    Serial.println("ACK:PONG");
    break;

  case 'S': // Status
    Serial.print("ACK:PWM:");
    Serial.print(fanPWM);
    Serial.print(",RPM:");
    Serial.print(fanRPM);
    Serial.print(",HARMONY:");
    Serial.println(harmonyEnabled ? "ON" : "OFF");
    break;

  case 'R': // RPM Only
    Serial.print("ACK:RPM:");
    Serial.println(fanRPM);
    break;

  case 'E': // Express Emotion
    setEmotionFan(arg);
    playEmotionMelody(arg);
    Serial.print("ACK:EMOTION:");
    Serial.println(arg);
    break;

  case 'F': // Fan Control (0-255)
    setFanSpeed(constrain(arg.toInt(), 0, 255));
    Serial.print("ACK:FAN:");
    Serial.println(fanPWM);
    break;

  case 'N': // Play Note
  {
    int spaceIdx = arg.indexOf(' ');
    if (spaceIdx > 0) {
      int freq = arg.substring(0, spaceIdx).toInt();
      int dur = arg.substring(spaceIdx + 1).toInt();
      playNote(freq, dur);
      Serial.println("ACK:OK");
    } else {
      Serial.println("NAK:FMT");
    }
  } break;

  case 'M': // Play Melody
    playMelody(arg);
    Serial.println("ACK:MELODY_DONE");
    break;

  case 'H': // Harmony Toggle
    harmonyEnabled = (arg.charAt(0) == '1');
    Serial.print("ACK:HARMONY:");
    Serial.println(harmonyEnabled ? "ON" : "OFF");
    break;

  case 'T': // Test/Debug
    Serial.print("ACK:PULSES:");
    Serial.print(pulseCount);
    Serial.print(",RPM:");
    Serial.print(fanRPM);
    Serial.print(",PWM:");
    Serial.print(fanPWM);
    Serial.print(",OCR1B:");
    Serial.print(OCR1B);
    Serial.print(",TACH:");
    Serial.println(digitalRead(FAN_TACH_PIN));
    break;

  case 'G': // Generation info (new command for evolution tracking)
    Serial.print("ACK:GEN:<%= @g.generation %>,FIT:<%= Float.round(@g.fitness, 4) %>");
    Serial.println();
    break;

  default:
    Serial.println("NAK:UNKNOWN_CMD");
  }

  digitalWrite(LED_PIN, LOW);
}

void playNote(int freq, int dur) {
  if (freq > 0) {
    tone(SPEAKER_PIN, freq, dur);
    if (harmonyEnabled) {
      tone(BUZZER_PIN, (int)(freq * HARMONY_RATIO), dur);
    }
    digitalWrite(LED_PIN, HIGH);
    delay(dur);
    digitalWrite(LED_PIN, LOW);
  } else {
    delay(dur); // Rest
  }
  noTone(SPEAKER_PIN);
  noTone(BUZZER_PIN);
  delay(20);
}

void playMelody(String melodyStr) {
  int start = 0;
  while (start < melodyStr.length()) {
    int semicolon = melodyStr.indexOf(';', start);
    if (semicolon == -1)
      semicolon = melodyStr.length();

    String noteStr = melodyStr.substring(start, semicolon);
    int comma = noteStr.indexOf(',');

    if (comma > 0) {
      int freq = noteStr.substring(0, comma).toInt();
      int dur = noteStr.substring(comma + 1).toInt();
      playNote(freq, dur);
    }

    start = semicolon + 1;
  }
}

// Emotion -> Fan speed mapping (evolved)
void setEmotionFan(String emotion) {
  byte pwm;
<% emotion_order = [:joy, :sad, :fear, :calm, :curious, :love] %>
<%= for {emotion_name, idx} <- Enum.with_index(emotion_order) do %>
<% emotion_data = Map.get(@g.emotions, emotion_name, %{pwm: 128}) %>
  <%= if idx == 0 do %>if<% else %>else if<% end %> (emotion == "<%= emotion_name %>")
    pwm = <%= emotion_data.pwm %>;
<% end %>
  else
    pwm = 128;

  setFanSpeed(pwm);
}

// Emotion -> Melody mapping (evolved)
void playEmotionMelody(String emotion) {
<%= for {emotion_name, idx} <- Enum.with_index(emotion_order) do %>
<% emotion_data = Map.get(@g.emotions, emotion_name, %{pwm: 128, melody: []}) %>
  <%= if idx == 0 do %>if<% else %>} else if<% end %> (emotion == "<%= emotion_name %>") {
<%= if Map.get(emotion_data, :repeat) do %>
    for (int i = 0; i < <%= emotion_data.repeat %>; i++) {
<%= for {freq, dur} <- emotion_data.melody do %>
      playNote(<%= freq %>, <%= dur %>);
<% end %>
    }
<% else %>
<%= for {freq, dur} <- emotion_data.melody do %>
    playNote(<%= freq %>, <%= dur %>);
<% end %>
<% end %>
<% end %>
  }
}
