//// Arduino Code Generator for VIVA-Link
////
//// Meta-programming: Gleam generates Arduino C++ headers and implementation
//// ensuring type-safety across the Soul-Body boundary.

import gleam/int
import gleam/io
import gleam/list
import gleam/string
import simplifile

// ============================================================================
// Field Types
// ============================================================================

/// Supported field types for Arduino structs
pub type FieldType {
  TypeUint8
  TypeInt8
  TypeUint16
  TypeInt16
  TypeUint32
  TypeInt32
  TypeFloat32
  TypeBool
}

/// A field in a packet struct
pub type Field {
  Field(name: String, field_type: FieldType)
}

/// A packet definition
pub type PacketDef {
  PacketDef(
    id: Int,
    name: String,
    direction: Direction,
    fields: List(Field),
  )
}

/// Direction of packet flow
pub type Direction {
  ToBody      // Gleam -> Arduino
  ToSoul      // Arduino -> Gleam
  Bidirectional
}

// ============================================================================
// VIVA-Link Packet Definitions
// ============================================================================

/// All VIVA-Link packets (single source of truth)
pub fn viva_packets() -> List(PacketDef) {
  [
    PacketDef(0x00, "Heartbeat", Bidirectional, []),

    PacketDef(0x01, "SensorData", ToSoul, [
      Field("temperature", TypeFloat32),
      Field("light", TypeUint16),
      Field("touch", TypeBool),
      Field("audio_level", TypeUint16),
    ]),

    PacketDef(0x02, "Command", ToBody, [
      Field("servo_angle", TypeInt16),
      Field("led_state", TypeBool),
      Field("vibration", TypeUint8),
    ]),

    PacketDef(0x10, "PadState", ToBody, [
      Field("pleasure", TypeFloat32),
      Field("arousal", TypeFloat32),
      Field("dominance", TypeFloat32),
    ]),

    PacketDef(0x11, "AudioCommand", ToBody, [
      Field("freq_left", TypeUint16),
      Field("freq_right", TypeUint16),
      Field("duration_ms", TypeUint16),
      Field("waveform", TypeUint8),
    ]),

    PacketDef(0xFE, "Ack", Bidirectional, [
      Field("acked_seq", TypeUint8),
    ]),

    PacketDef(0xFF, "ErrorPacket", ToSoul, [
      Field("error_code", TypeUint8),
    ]),
  ]
}

// ============================================================================
// C++ Code Generation
// ============================================================================

/// Generate complete Arduino header file
pub fn generate_header() -> String {
  let packets = viva_packets()

  let header = "
/*
 * VIVA-Link Protocol - Auto-generated by viva/codegen/arduino_gen.gleam
 * DO NOT EDIT MANUALLY - regenerate with: gleam run -m viva/codegen/arduino_gen
 *
 * This header defines all packet types for Soul <-> Body communication.
 */

#ifndef VIVA_PACKETS_H
#define VIVA_PACKETS_H

#include <stdint.h>
#include <stdbool.h>

// ============================================================================
// Packet Type IDs
// ============================================================================

"

  let type_ids = list.map(packets, fn(p) {
    "#define VIVA_TYPE_" <> string.uppercase(p.name) <> " 0x" <> int_to_hex(p.id)
  }) |> string.join("\n")

  let structs = list.map(packets, generate_struct) |> string.join("\n\n")

  let parser = generate_parser(packets)

  header <> type_ids <> "

// ============================================================================
// Packet Structures (packed for wire format)
// ============================================================================

" <> structs <> "

// ============================================================================
// Packet Parser
// ============================================================================

" <> parser <> "

#endif // VIVA_PACKETS_H
"
}

fn generate_struct(packet: PacketDef) -> String {
  let fields = case list.length(packet.fields) {
    0 -> "    // No payload fields"
    _ -> list.map(packet.fields, fn(f) {
      "    " <> type_to_c(f.field_type) <> " " <> f.name <> ";"
    }) |> string.join("\n")
  }

  let dir = case packet.direction {
    ToBody -> "Soul -> Body"
    ToSoul -> "Body -> Soul"
    Bidirectional -> "Bidirectional"
  }

  "// " <> packet.name <> " (" <> dir <> ")
struct __attribute__((packed)) Viva" <> packet.name <> " {
    uint8_t type_id = VIVA_TYPE_" <> string.uppercase(packet.name) <> ";
    uint8_t seq;
" <> fields <> "
};"
}

fn generate_parser(packets: List(PacketDef)) -> String {
  let cases = list.map(packets, fn(p) {
    "        case VIVA_TYPE_" <> string.uppercase(p.name) <> ":
            if (size >= sizeof(Viva" <> p.name <> ")) {
                memcpy(&pkt_" <> string.lowercase(p.name) <> ", buffer, sizeof(Viva" <> p.name <> "));
                return VIVA_TYPE_" <> string.uppercase(p.name) <> ";
            }
            break;"
  }) |> string.join("\n")

  let storage = list.map(packets, fn(p) {
    "Viva" <> p.name <> " pkt_" <> string.lowercase(p.name) <> ";"
  }) |> string.join("\n")

  "// Packet storage (union would be better but this is clearer)
" <> storage <> "

// Parse a received packet, returns type_id or -1 on error
inline int8_t vivaParsePacket(const uint8_t* buffer, size_t size) {
    if (size < 2) return -1;  // Minimum: type + seq

    uint8_t type_id = buffer[0];

    switch (type_id) {
" <> cases <> "
        default:
            return -1;  // Unknown type
    }
    return -1;  // Size mismatch
}
"
}

fn type_to_c(t: FieldType) -> String {
  case t {
    TypeUint8 -> "uint8_t"
    TypeInt8 -> "int8_t"
    TypeUint16 -> "uint16_t"
    TypeInt16 -> "int16_t"
    TypeUint32 -> "uint32_t"
    TypeInt32 -> "int32_t"
    TypeFloat32 -> "float"
    TypeBool -> "bool"
  }
}

fn int_to_hex(n: Int) -> String {
  case n {
    0 -> "00"
    _ -> {
      let high = n / 16
      let low = n % 16
      hex_digit(high) <> hex_digit(low)
    }
  }
}

fn hex_digit(n: Int) -> String {
  case n {
    0 -> "0"
    1 -> "1"
    2 -> "2"
    3 -> "3"
    4 -> "4"
    5 -> "5"
    6 -> "6"
    7 -> "7"
    8 -> "8"
    9 -> "9"
    10 -> "A"
    11 -> "B"
    12 -> "C"
    13 -> "D"
    14 -> "E"
    15 -> "F"
    _ -> "?"
  }
}

// ============================================================================
// File Output
// ============================================================================

/// Generate and write the Arduino header file
pub fn write_header(path: String) -> Result(Nil, simplifile.FileError) {
  let content = generate_header()
  simplifile.write(path, content)
}

/// Main entry point for code generation
pub fn main() {
  let path = "arduino/viva_body/viva_packets.h"
  case write_header(path) {
    Ok(_) -> {
      io.println("Generated: " <> path)
    }
    Error(e) -> {
      io.println("Error writing file: " <> string.inspect(e))
    }
  }
}
