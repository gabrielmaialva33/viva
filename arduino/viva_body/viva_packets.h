
/*
 * VIVA-Link Protocol - Auto-generated by viva/codegen/arduino_gen.gleam
 * DO NOT EDIT MANUALLY - regenerate with: gleam run -m viva/codegen/arduino_gen
 *
 * This header defines all packet types for Soul <-> Body communication.
 */

#ifndef VIVA_PACKETS_H
#define VIVA_PACKETS_H

#include <stdint.h>
#include <stdbool.h>

// ============================================================================
// Packet Type IDs
// ============================================================================

#define VIVA_TYPE_HEARTBEAT 0x00
#define VIVA_TYPE_SENSORDATA 0x01
#define VIVA_TYPE_COMMAND 0x02
#define VIVA_TYPE_PADSTATE 0x10
#define VIVA_TYPE_AUDIOCOMMAND 0x11
#define VIVA_TYPE_ACK 0xFE
#define VIVA_TYPE_ERRORPACKET 0xFF

// ============================================================================
// Packet Structures (packed for wire format)
// ============================================================================

// Heartbeat (Bidirectional)
struct __attribute__((packed)) VivaHeartbeat {
    uint8_t type_id = VIVA_TYPE_HEARTBEAT;
    uint8_t seq;
    // No payload fields
};

// SensorData (Body -> Soul)
struct __attribute__((packed)) VivaSensorData {
    uint8_t type_id = VIVA_TYPE_SENSORDATA;
    uint8_t seq;
    float temperature;
    uint16_t light;
    bool touch;
    uint16_t audio_level;
};

// Command (Soul -> Body)
struct __attribute__((packed)) VivaCommand {
    uint8_t type_id = VIVA_TYPE_COMMAND;
    uint8_t seq;
    int16_t servo_angle;
    bool led_state;
    uint8_t vibration;
};

// PadState (Soul -> Body)
struct __attribute__((packed)) VivaPadState {
    uint8_t type_id = VIVA_TYPE_PADSTATE;
    uint8_t seq;
    float pleasure;
    float arousal;
    float dominance;
};

// AudioCommand (Soul -> Body)
struct __attribute__((packed)) VivaAudioCommand {
    uint8_t type_id = VIVA_TYPE_AUDIOCOMMAND;
    uint8_t seq;
    uint16_t freq_left;
    uint16_t freq_right;
    uint16_t duration_ms;
    uint8_t waveform;
};

// Ack (Bidirectional)
struct __attribute__((packed)) VivaAck {
    uint8_t type_id = VIVA_TYPE_ACK;
    uint8_t seq;
    uint8_t acked_seq;
};

// ErrorPacket (Body -> Soul)
struct __attribute__((packed)) VivaErrorPacket {
    uint8_t type_id = VIVA_TYPE_ERRORPACKET;
    uint8_t seq;
    uint8_t error_code;
};

// ============================================================================
// Packet Parser
// ============================================================================

// Packet storage (union would be better but this is clearer)
VivaHeartbeat pkt_heartbeat;
VivaSensorData pkt_sensordata;
VivaCommand pkt_command;
VivaPadState pkt_padstate;
VivaAudioCommand pkt_audiocommand;
VivaAck pkt_ack;
VivaErrorPacket pkt_errorpacket;

// Parse a received packet, returns type_id or -1 on error
inline int8_t vivaParsePacket(const uint8_t* buffer, size_t size) {
    if (size < 2) return -1;  // Minimum: type + seq

    uint8_t type_id = buffer[0];

    switch (type_id) {
        case VIVA_TYPE_HEARTBEAT:
            if (size >= sizeof(VivaHeartbeat)) {
                memcpy(&pkt_heartbeat, buffer, sizeof(VivaHeartbeat));
                return VIVA_TYPE_HEARTBEAT;
            }
            break;
        case VIVA_TYPE_SENSORDATA:
            if (size >= sizeof(VivaSensorData)) {
                memcpy(&pkt_sensordata, buffer, sizeof(VivaSensorData));
                return VIVA_TYPE_SENSORDATA;
            }
            break;
        case VIVA_TYPE_COMMAND:
            if (size >= sizeof(VivaCommand)) {
                memcpy(&pkt_command, buffer, sizeof(VivaCommand));
                return VIVA_TYPE_COMMAND;
            }
            break;
        case VIVA_TYPE_PADSTATE:
            if (size >= sizeof(VivaPadState)) {
                memcpy(&pkt_padstate, buffer, sizeof(VivaPadState));
                return VIVA_TYPE_PADSTATE;
            }
            break;
        case VIVA_TYPE_AUDIOCOMMAND:
            if (size >= sizeof(VivaAudioCommand)) {
                memcpy(&pkt_audiocommand, buffer, sizeof(VivaAudioCommand));
                return VIVA_TYPE_AUDIOCOMMAND;
            }
            break;
        case VIVA_TYPE_ACK:
            if (size >= sizeof(VivaAck)) {
                memcpy(&pkt_ack, buffer, sizeof(VivaAck));
                return VIVA_TYPE_ACK;
            }
            break;
        case VIVA_TYPE_ERRORPACKET:
            if (size >= sizeof(VivaErrorPacket)) {
                memcpy(&pkt_errorpacket, buffer, sizeof(VivaErrorPacket));
                return VIVA_TYPE_ERRORPACKET;
            }
            break;
        default:
            return -1;  // Unknown type
    }
    return -1;  // Size mismatch
}


#endif // VIVA_PACKETS_H
